---
description: Generate implementation plan for the current issue
argument-hint: [additional-requirements]
allowed-tools: [Read, Write, Bash, SlashCommand, mcp__linear-server__get_issue, mcp__linear-server__list_comments, mcp__linear-server__create_comment]
---

# Task

Generate an **implementation plan** for the active issue in `.ctx.current`.

**Important**: This command generates the **HOW** (implementation details), NOT the **WHAT** (requirements/spec). The user has already written the spec.

---

# Workflow

## Step 1: Read `.ctx.current`

Check if `.ctx.current` exists:
```typescript
if (!fs.existsSync('.ctx.current')) {
  // Error: No active issue
}
```

Read the current issue:
```json
{
  "issue": "{{global.directory}}/issues/2025-11-19-1430_add-dark-mode.md"
  // or
  "issue": "https://github.com/user/repo/issues/123"
}
```

---

## Step 2: Detect Online vs Offline

Check if `issue` value starts with `http`:
- **Yes** ÔøΩ Online issue (Flow A)
- **No** ÔøΩ Offline issue (Flow B)

---

## Flow A: Online Issue

### A1. Fetch Issue from Provider

**For GitHub:**
```bash
gh issue view <number> --json title,body,url
gh issue view <number> --json comments
```

**For Linear:**
```
mcp__linear-server__get_issue(issueId: "ABC-123")
mcp__linear-server__list_comments(issueId: "ABC-123")
```

Extract:
- **Title**: Issue title
- **Spec**: Description/body (this is the user's requirements)
- **Comments**: Check for additional requirements in comments

### A2. Parse Additional Requirements

If `$ARGUMENTS` provided, append to Spec:
```
Original Spec: <from issue description>

Additional Requirements:
<from $ARGUMENTS>
```

### A3. Load Relevant Contexts

Extract key technical terms from Spec (e.g., "authentication", "React", "dark mode", "settings").

Use the SlashCommand tool to load relevant contexts:
```
SlashCommand(command: "/ctx.load <keywords-from-spec>")
```

Example: If Spec mentions "dark mode toggle in settings page", extract keywords like "dark mode", "settings", "theme" and run:
```
SlashCommand(command: "/ctx.load dark mode settings theme")
```

This provides codebase context for planning.

### A4. Q&A Session (Implementation Focus)

**IMPORTANT**: This is an **AI self-analysis** step, NOT user interaction. The AI should analyze the codebase context and spec, then generate implementation questions and answers autonomously.

**Process**:
1. AI analyzes the Spec and loaded codebase context
2. AI generates implementation questions (what files, architecture, patterns, etc.)
3. AI answers these questions based on codebase analysis
4. AI documents the Q&A in the plan

**Questions to generate and answer**:
- What files will be modified?
- What files will be created?
- What existing code can be reused?
- What are the main interfaces/types needed?
- How will the architecture change?
- Will you write tests?
- What are the main technical challenges?

**Format**:
```markdown
## Q&A

**Q: What files will be modified?**
A: `src/pages/Settings.tsx`, `src/App.tsx`, `src/styles/theme.css`

**Q: What files will be created?**
A: `src/contexts/ThemeContext.tsx`, `src/components/DarkModeToggle.tsx`

...
```

**Note**: Do NOT ask the user these questions. The AI should answer them autonomously based on codebase analysis.

### A5. Generate Implementation Plan

Create structured plan with:

```markdown
## Phases

### Phase 1: <Name>

**Step 1: <Task>**
- [ ] <Subtask>
- [ ] <Subtask>

**Step 2: <Task>**
- [ ] <Subtask>

### Phase 2: <Name>
...

## Files to Modify
- `file1.ts` - <what changes>
- `file2.ts` - <what changes>

## Files to Create
- `newfile.ts` - <purpose>

## Files/Objects to Reuse
- `existing.ts` - `functionName()` - <how to use>

## Notes
- <Technical considerations>
- <Edge cases>
- <Performance notes>
```

### A6. Sync Plan to Issue

**For GitHub:**

Use Bash tool to post comment and capture the comment URL:
```bash
gh issue comment <number> --body "---

## üéØ Implementation Plan

<plan content>

---

_Generated by ctx at $(date -u +%Y-%m-%dT%H:%M:%SZ)_"
```

The GitHub CLI output will contain the comment URL. Extract it for the summary.

**For Linear:**

Use MCP tool to create comment:
```
mcp__linear-server__create_comment(
  issueId: "ABC-123",
  body: "## üéØ Implementation Plan\n\n<plan content>\n\n_Generated by ctx at $(date -u +%Y-%m-%dT%H:%M:%SZ)_"
)
```

The MCP response will contain the comment data. Extract the comment ID and construct URL: `{issue_url}#comment-{comment_id}`

### A7. Show Summary

Display the result with the actual comment URL from step A6:

```
‚úì Implementation plan synced to <platform> issue
üìé View: <actual-comment-url>

Ready to start coding!
```

**Note**: Replace `<actual-comment-url>` with the URL obtained from GitHub CLI or Linear MCP response.

---

## Flow B: Offline Issue

### B1. Read Issue File

Read the issue file:
```markdown
---
title: Add dark mode toggle
source: local
provider: local
status: initialized
...
---

# Spec

<user's requirements>

<!-- Implementation Plan will be added by /ctx.work.plan -->
```

Extract:
- **Frontmatter**: Issue metadata
- **Spec**: User's requirements
- **Existing Plan**: Check if plan already exists

### B2. Check Existing Plan

If plan already exists:
```
‚ö†Ô∏è Implementation plan already exists. Override? (y/n)
```

If user says no, exit.

### B3. Parse Additional Requirements

Same as Flow A step A2.

### B4. Load Relevant Contexts

Same as Flow A step A3.

### B5. Q&A Session

Same as Flow A step A4.

### B6. Generate Implementation Plan

Same as Flow A step A5.

### B7. Save Plan to File

Generate current timestamp in ISO 8601 format using Bash:
```bash
date -u +%Y-%m-%dT%H:%M:%SZ
```

**If no existing plan**: Append to file:
```markdown
---

# Implementation Plan

_Generated at <current-timestamp>_

<plan content>
```

**If overriding**: Replace existing plan section:
```markdown
# Implementation Plan

_Generated at <original-timestamp>_
_Last updated at <current-timestamp>_

<plan content>
```

### B8. Update Frontmatter

Update issue file frontmatter with current timestamp:
```yaml
---
status: in_progress  # changed from 'initialized'
updated_at: <current-timestamp>
---
```

Use Edit tool to update the frontmatter while preserving other fields.

### B9. Show Summary

```
‚úì Implementation plan added to <filename>
üìé Commit this file to share with team

Ready to start coding!
```

---

# Error Handling

- **No `.ctx.current`**:
  ```
  ‚ùå Error: No active issue
  Run /ctx.work.init first to initialize an issue
  ```
- **GitHub CLI not available**: Show installation instructions
- **Linear MCP not available**: Show MCP setup instructions
- **File not found** (offline): Issue file was deleted or moved
- **Invalid frontmatter**: Issue file format is incorrect

---

# Important Guidelines

## What to Ask (Implementation)
‚úì Which files will change?
‚úì What patterns/architecture to use?
‚úì What existing code to reuse?
‚úì What are the technical challenges?
‚úì Will you write tests?

## What NOT to Ask (Spec)
‚ùå What should this feature do?
‚ùå What are the requirements?
‚ùå What problem are we solving?
‚ùå Who are the users?

**Reason**: The user has already written the spec. We're only planning HOW to implement it, not WHAT to implement.

## Plan Quality
- **Actionable**: Each step should be clear and concrete
- **Phased**: Group related tasks into logical phases
- **Detailed**: Include file names, function names, key decisions
- **Testable**: Include testing strategy
- **Realistic**: Consider edge cases and technical constraints

## Context Loading
- Extract key technical terms from Spec (e.g., "authentication", "React", "API")
- Load relevant contexts before planning
- This ensures plan is grounded in actual codebase

---

# Examples

## Good Q&A (Implementation Focus)

```markdown
## Q&A

**Q: What files will be modified?**
A: `src/pages/Settings.tsx` (add toggle UI), `src/App.tsx` (wrap with ThemeProvider), `src/styles/theme.css` (add CSS variables)

**Q: What files will be created?**
A: `src/contexts/ThemeContext.tsx` (theme state management), `src/components/DarkModeToggle.tsx` (toggle component)

**Q: What existing code can be reused?**
A: `src/utils/localStorage.ts` has `getItem()` and `setItem()` functions. `src/contexts/AuthContext.tsx` shows the pattern for context providers.

**Q: What are the main interfaces/types?**
A:
\`\`\`typescript
type Theme = 'light' | 'dark';
interface ThemeContextValue {
  theme: Theme;
  toggleTheme: () => void;
}
\`\`\`

**Q: Will you write tests?**
A: Yes. Unit tests for ThemeContext (initial state, toggleTheme, localStorage persistence), component tests for DarkModeToggle (rendering, click behavior).
```

## Bad Q&A (Spec Focus - Don't Do This)

```markdown
L Q: What should the dark mode feature do?
‚ùå Q: Where should the toggle be placed?
‚ùå Q: Should we support system preference?
```

These are spec questions. The user has already answered them in the Spec section!
