#!/usr/bin/env node
/**
 * CTX Auto-Load Context Hook
 *
 * Triggered on PostToolUse(Read) to automatically inject context
 * when reading a file that matches a context's target pattern.
 *
 * Priority:
 *   1. Project registry - exact match
 *   2. Global registry - exact match
 *   3. Project registry - glob match
 *   4. Global registry - glob match
 *
 * Input: JSON from stdin with tool_name, tool_input, tool_response
 * Output: additionalContext to stdout (will be injected into conversation)
 */

import fs from 'fs/promises';
import path from 'path';
import os from 'os';
import { minimatch } from 'minimatch';

// Types
interface ContextEntry {
  target?: string;
  checksum?: string;
  preview?: {
    what?: string;
    when?: string[];
  };
}

interface UnifiedRegistry {
  meta?: {
    version?: string;
    last_synced?: string;
  };
  contexts?: Record<string, ContextEntry>;
}

interface MatchedContext {
  contextPath: string;  // Path to the context file
  target: string;       // The target pattern
  source: 'project' | 'global';
  matchType: 'exact' | 'glob';
  priority: number;     // Lower = higher priority
  preview?: {
    what?: string;
  };
}

// Constants
const CTX_DIR = '.ctx';
const REGISTRY_FILE = 'registry.yaml';
const GLOBAL_CTX_DIR = path.join(os.homedir(), CTX_DIR);

/**
 * Simple YAML parser for registry files
 * (Avoids dependency on 'yaml' package for the hook script)
 */
function parseYaml(content: string): UnifiedRegistry {
  // For hook script, we use dynamic import
  // But for simplicity, let's just parse it manually or use require
  // Actually, let's use dynamic import since the project is ESM
  throw new Error('Use parseYamlAsync instead');
}

async function parseYamlAsync(content: string): Promise<UnifiedRegistry> {
  const YAML = await import('yaml');
  return YAML.parse(content) as UnifiedRegistry;
}

/**
 * Read registry file
 */
async function readRegistry(registryPath: string): Promise<UnifiedRegistry> {
  try {
    const content = await fs.readFile(registryPath, 'utf-8');
    return await parseYamlAsync(content);
  } catch {
    return { contexts: {} };
  }
}

/**
 * Find project root by traversing up and looking for .ctx/registry.yaml
 */
async function findProjectRoot(startPath: string): Promise<string | null> {
  let currentPath = path.resolve(startPath);
  const root = path.parse(currentPath).root;

  while (currentPath !== root) {
    const registryPath = path.join(currentPath, CTX_DIR, REGISTRY_FILE);
    try {
      await fs.access(registryPath);
      return currentPath;
    } catch {
      currentPath = path.dirname(currentPath);
    }
  }

  return null;
}

/**
 * Check if target pattern is a glob pattern
 */
function isGlobPattern(pattern: string): boolean {
  return pattern.includes('*') || pattern.includes('?') || pattern.includes('[');
}

/**
 * Check if file path matches a target pattern
 */
function matchesTarget(filePath: string, target: string, projectRoot: string): boolean {
  // Normalize paths
  const normalizedFile = filePath.startsWith('/')
    ? filePath
    : path.join(projectRoot, filePath);

  const relativePath = path.relative(projectRoot, normalizedFile);

  // Handle folder targets (ending with /)
  if (target.endsWith('/')) {
    return relativePath.startsWith(target) || relativePath.startsWith(target.slice(0, -1));
  }

  if (isGlobPattern(target)) {
    // Glob match
    return minimatch(relativePath, target, { dot: true });
  } else {
    // Exact match
    return relativePath === target || relativePath === target.replace(/^\//, '');
  }
}

/**
 * Find matching contexts from a registry
 */
function findMatchingContexts(
  registry: UnifiedRegistry,
  filePath: string,
  projectRoot: string,
  source: 'project' | 'global',
  basePath: string
): MatchedContext[] {
  const matches: MatchedContext[] = [];

  if (!registry.contexts) {
    return matches;
  }

  for (const [contextKey, entry] of Object.entries(registry.contexts)) {
    if (!entry.target) {
      // Skip contexts without target (manual load only)
      continue;
    }

    if (matchesTarget(filePath, entry.target, projectRoot)) {
      const isGlob = isGlobPattern(entry.target) || entry.target.endsWith('/');

      // Priority: Project exact (1) > Global exact (2) > Project glob (3) > Global glob (4)
      let priority: number;
      if (!isGlob) {
        priority = source === 'project' ? 1 : 2;
      } else {
        priority = source === 'project' ? 3 : 4;
      }

      matches.push({
        contextPath: path.join(basePath, contextKey),
        target: entry.target,
        source,
        matchType: isGlob ? 'glob' : 'exact',
        priority,
        preview: entry.preview,
      });
    }
  }

  return matches;
}

/**
 * Load context file content
 */
async function loadContextContent(contextPath: string): Promise<string | null> {
  try {
    return await fs.readFile(contextPath, 'utf-8');
  } catch {
    return null;
  }
}

/**
 * Main function
 */
async function main(): Promise<void> {
  // Read input from stdin
  let input = '';
  for await (const chunk of process.stdin) {
    input += chunk;
  }

  if (!input.trim()) {
    process.exit(0);
  }

  let parsedInput: { tool_input?: { file_path?: string } };
  try {
    parsedInput = JSON.parse(input);
  } catch {
    process.exit(0);
  }

  const filePath = parsedInput.tool_input?.file_path;
  if (!filePath) {
    process.exit(0);
  }

  // Skip if already reading a context file
  if (filePath.endsWith('.ctx.md') || filePath.endsWith('/ctx.md')) {
    process.exit(0);
  }

  // Skip if reading from .ctx directory
  if (filePath.includes('/.ctx/')) {
    process.exit(0);
  }

  // Find project root
  const fileDir = path.dirname(filePath);
  const projectRoot = await findProjectRoot(fileDir);

  // Collect all matching contexts
  const allMatches: MatchedContext[] = [];

  // Check project registry
  if (projectRoot) {
    const projectRegistryPath = path.join(projectRoot, CTX_DIR, REGISTRY_FILE);
    const projectRegistry = await readRegistry(projectRegistryPath);
    const projectMatches = findMatchingContexts(
      projectRegistry,
      filePath,
      projectRoot,
      'project',
      projectRoot
    );
    allMatches.push(...projectMatches);
  }

  // Check global registry
  const globalRegistryPath = path.join(GLOBAL_CTX_DIR, REGISTRY_FILE);
  const globalRegistry = await readRegistry(globalRegistryPath);
  const globalMatches = findMatchingContexts(
    globalRegistry,
    filePath,
    projectRoot || path.dirname(filePath),
    'global',
    GLOBAL_CTX_DIR
  );
  allMatches.push(...globalMatches);

  if (allMatches.length === 0) {
    process.exit(0);
  }

  // Sort by priority
  allMatches.sort((a, b) => a.priority - b.priority);

  // Load and output contexts
  const outputs: string[] = [];

  for (const match of allMatches) {
    const content = await loadContextContent(match.contextPath);
    if (content) {
      const relativePath = projectRoot
        ? path.relative(projectRoot, match.contextPath)
        : match.contextPath;

      const matchTypeLabel = match.matchType === 'exact' ? 'exact' : 'pattern';
      const sourceLabel = match.source === 'project' ? 'Project' : 'Global';

      outputs.push(`
---
**Context loaded:** \`${relativePath}\` (${sourceLabel}, ${matchTypeLabel}: \`${match.target}\`)
${match.preview?.what ? `> ${match.preview.what}` : ''}

${content}
---`);
    }
  }

  if (outputs.length > 0) {
    console.log(outputs.join('\n'));
  }
}

main().catch((error) => {
  console.error('Error in auto-load-context:', error);
  process.exit(1);
});
