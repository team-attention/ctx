#!/bin/bash
#
# CTX Auto-Load Context Hook
#
# Triggered on PostToolUse(Read) to automatically inject companion context
# when reading a code file that has an associated .ctx.md file.
#
# Input: JSON from stdin with tool_name, tool_input, tool_response
# Output: additionalContext to stdout (will be injected into conversation)

set -e

# Read input from stdin
input=$(cat)

# Extract file path from tool input
file_path=$(echo "$input" | jq -r '.tool_input.file_path // empty')

# Exit if no file path
if [ -z "$file_path" ]; then
  exit 0
fi

# Skip if already reading a context file
if [[ "$file_path" == *.ctx.md ]] || [[ "$file_path" == */ctx.md ]]; then
  exit 0
fi

# Skip if reading from .ctx directory
if [[ "$file_path" == */.ctx/* ]] || [[ "$file_path" == */.ctx ]]; then
  exit 0
fi

# Skip common non-code files
case "$file_path" in
  *.json|*.yaml|*.yml|*.md|*.txt|*.log|*.lock|*.toml|*.xml|*.html|*.css)
    exit 0
    ;;
esac

# Determine companion context path
# For src/api.ts -> src/api.ctx.md
# For src/utils/helpers.ts -> src/utils/helpers.ctx.md
dir=$(dirname "$file_path")
base=$(basename "$file_path")
name="${base%.*}"  # Remove extension

companion_path="$dir/$name.ctx.md"

# Also check for folder-level context
folder_context="$dir/ctx.md"

# Check if companion context exists
context_content=""

if [ -f "$companion_path" ]; then
  context_content=$(cat "$companion_path")
  context_source="$companion_path"
elif [ -f "$folder_context" ]; then
  context_content=$(cat "$folder_context")
  context_source="$folder_context"
fi

# If context found, output it
if [ -n "$context_content" ]; then
  # Output as additional context
  # Claude Code will inject this into the conversation
  echo ""
  echo "---"
  echo "**Context loaded:** \`$context_source\`"
  echo ""
  echo "$context_content"
  echo "---"
fi

exit 0
