# Agent Council Review: 3-Level Context System

> CTX 프로젝트 개선안에 대한 AI Agent Council 리뷰
> 리뷰일: 2025-12-29
> Council 멤버: Codex, Gemini
> Chairman: Claude (Opus 4.5)

---

## Council 구성

| Agent | 역할 | 특성 |
|-------|------|------|
| Codex (OpenAI) | Council Member | 코드 중심, 실용적 접근 |
| Gemini (Google) | Council Member | 폭넓은 지식, 다양한 관점 |
| Claude (Anthropic) | Chairman | 종합 및 최종 판단 |

---

## 리뷰 대상

### 개선안 요약
1. **Global (~/.ctx/)**: 사용자 전역, 모든 프로젝트에서 참조
2. **Project ({project}/.ctx/)**: 프로젝트 단위 컨텍스트
3. **Local (*.ctx.md, ctx.md)**: 특정 파일/폴더에 붙은 컨텍스트

### 핵심 변경
- ctx/ → .ctx/로 이동 (dotfile 관례)
- ~/.ctx/ 새로 추가 (Global level)
- PostToolUse hook으로 자동 컨텍스트 로드
- work 관련 워크플로우 단순화

### 리뷰 질문
1. 3-level 구조가 적절한가?
2. Global을 ~/.ctx/에 두는 게 맞는가?
3. 자동 로드 전략이 효과적일까?
4. 기존 work 워크플로우를 어떻게 단순화해야 할까?
5. 놓치고 있는 관점이 있는가?

---

## Codex 의견

### 전반적 평가
> 전반적으로 3-level 분리는 자연스럽고 사용자 정신모델에도 잘 맞습니다.

### 질문별 답변

#### 1. 3-level 구조 적절성
**적절합니다.**
- 범용(습관/도구) → 프로젝트(아키텍처/도메인) → 로컬(파일/폴더 전용)로 점진적 특이성이 쌓이는 구조
- 이해·탐색·충돌 해소 모두에 유리
- Local을 파일/폴더 스코프로 분리한 점이 컨텍스트 과적재를 줄임

#### 2. ~/.ctx/ 위치
**합리적입니다.**
- dotfile 관례와 일치
- 홈 디렉터리 백업/동기화 전략과도 잘 맞음
- 다만 다중 머신/회사 계정 분리를 고려하면 `~/.config/ctx/` 대안도 문서화 권장

#### 3. 자동 로드 전략
**효과적일 가능성이 큽니다.**

단, 주의사항:
- "자동 로드가 어떤 시점/범위에서 동작하는지"가 명확해야 함
- 불명확하면 과도한 로드/혼란 발생

**권장사항:**
- PostToolUse hook에서 "최근 접근한 파일/폴더의 Local → Project → Global" 순으로 제한적 로드
- 로드 결과를 짧게 요약해 사용자에게 보여주되 끌 수 있도록 옵션 제공

#### 4. work 워크플로우 단순화
**"work = 선택적 묶음/세션" 정도로 격하하는 방향이 좋습니다.**
- 기본 플로우는 자동 컨텍스트 로드로 충분하게
- work는 "여러 프로젝트/디렉터리 묶기"나 "일시적 집중 세션" 역할로 재정의
- 혼자 쓸 때 부담이 줄어듦

#### 5. 놓치고 있는 관점
- **충돌/중복 처리**: Local/Project/Global 중복 규칙 정의 필요
- **민감정보/보안**: ~/.ctx/는 개인 지식이므로 동기화/백업 시 주의
- **성능/스케일링**: 자동 로드 시 파일 탐색 범위 제한 필요

### Codex 보완 제안

1. **충돌 정책**: "가장 구체적 레벨 우선 + 상위는 기본값" 규칙 명시, 동일 키 충돌 시 병합 방식(override/merge) 정의

2. **가이드 템플릿**: 각 레벨의 기본 템플릿 예시 제공
   - Global: 스타일·도구
   - Project: 아키텍처·기능
   - Local: 파일 목적·주의사항

3. **가시성/디버깅**: "어떤 컨텍스트가 로드됐는지" 짧게 확인할 수 있는 커맨드/로그 제공

4. **성능**: 자동 로드 시 파일 탐색 범위 제한(상위 N단계, ignore 패턴), 캐시 전략 명시

5. **보안**: `~/.ctx/`는 개인 지식이므로 민감정보 금지 원칙을 명확히

---

## Gemini 의견

### 전반적 평가
> 매우 훌륭한 설계입니다. Git 설정(`system` > `global` > `local`)이나 CSS 적용 우선순위처럼 이미 검증된 계층적 설정/컨텍스트 관리 패턴을 따르고 있습니다.

### 질문별 답변

#### 1. 3-level 구조 적절성
**네, 매우 적절하고 강력한 구조입니다.**

- **관심사의 분리**: 개인의 보편적 컨텍스트(Global), 프로젝트의 공유 컨텍스트(Project), 특정 코드의 상세 컨텍스트(Local)를 명확하게 분리
- **유연성 및 확장성**: 필요에 따라 특정 레벨의 컨텍스트만 구성 가능
- **직관적인 우선순위**: Local > Project > Global은 '가장 가까운 것이 가장 높은 권한'

#### 2. ~/.ctx/ 위치
**네, `~/.ctx/`는 Global 컨텍스트를 위한 최적의 위치입니다.**

- **관례 준수**: `~/.gitconfig`, `~/.aws`, `~/.ssh` 등 Unix 기반 시스템의 표준적인 관례
- **명확한 소유권**: 사용자 개인에게 속한 디렉토리, 프로젝트 저장소에 실수로 포함될 여지 없음

**고려사항:**
- `ctx init --global` 명령어 제공하여 자동 생성
- Windows의 `%USERPROFILE%` 환경 변수도 고려하여 플랫폼 독립적 구현

#### 3. 자동 로드 전략
**네, CTX의 핵심 가치를 극대화하는 매우 효과적인 방법입니다.**

**장점:**
- 명시적 `ctx load` 없이 자동으로 필요한 컨텍스트 로드
- '컨텍스트 추출을 잘 안 하게 되는' 문제를 정면으로 해결
- 컨텍스트를 공기처럼 당연하게 만들어 줌

**단점 (성능 위험):**
- PostToolUse hook 실행 시마다 파일 시스템 스캔은 성능 저하 유발 가능

**개선 제안:**
1. **캐싱(Caching)**: 로드한 컨텍스트를 메모리에 캐싱, 파일 변경 시만 재로드
2. **Manifest 파일**: registry.yml로 매번 스캔 대신 이 파일만 읽도록 최적화

#### 4. work 워크플로우 단순화
**강제적인 프로세스에서 유용한 유틸리티 모음으로 전환되어야 합니다.**

**단순화 방향:**

1. **work 명령어 분해/재정의:**
   - `ctx save`: 가볍게 상태를 저장하는 기능
   - `ctx log "메모"`: 타임스탬프와 함께 간단한 로그 추가
   - `ctx summary`: 현재까지 로드된 컨텍스트 요약

2. **프로세스 강제 제거:**
   - issue store 연동, 브랜치 자동 생성/전환, 커밋 메시지 템플릿 강제 등을 핵심에서 분리
   - 필요시 사용자가 hooks로 커스터마이징

3. **핵심은 ctx가 아닌 사용자:**
   - 사용자가 선호하는 Git 전략이나 개발 프로세스를 그대로 따름
   - ctx는 보조 역할로 만족

#### 5. 놓치고 있는 관점

1. **컨텍스트 가시성 (Context Visibility):**
   - "지금 어떤 컨텍스트가 로드되어 있지?" 쉽게 확인 필요
   - `ctx status` 명령어에 활성화된 Global, Project, Local 컨텍스트 목록과 우선순위 표시
   - "이 답변은 `api.ctx.md`의 영향을 받았습니다" 같은 출처 표시 (opt-in)

2. **Sync의 재정의:**
   - **Project Context (.ctx/)**: Git을 통해 팀원들과 자연스럽게 공유
   - **Global Context (~/.ctx/)**: 개인의 것이므로 sync 대상 아님
   - **Local Context (*.ctx.md)**: Git으로 관리할지 여부는 사용자 선택

3. **보안 및 민감 정보:**
   - `~/.ctx/`에 API 키나 개인 식별 정보 등 민감한 내용 포함 가능성
   - 비공개로 유지해야 함을 명확히 안내

---

## Chairman 종합 정리

### 공통 합의 사항

| 항목 | 결론 | 합의도 |
|------|------|--------|
| 3-level 구조 | **적절함** | 100% |
| `~/.ctx/` 위치 | **합리적** | 100% |
| 자동 로드 전략 | **효과적, 단 성능 주의** | 100% |
| work 단순화 | **필요함** | 100% |

### 핵심 인사이트

#### 강점
- Git 설정 패턴(`system > global > local`)과 동일한 검증된 구조
- "가장 구체적인 게 우선" 원칙이 직관적
- Unix dotfile 관례 준수로 익숙함

#### 주의사항
1. **성능**: 자동 로드 시 캐싱/registry 활용 필수
2. **가시성**: "뭐가 로드됐는지" 확인 방법 제공
3. **보안**: ~/.ctx/ 민감정보 금지 원칙 명시
4. **충돌 정책**: 레벨 간 중복 시 처리 규칙 정의

### 놓치고 있는 관점 종합

#### 필수 (두 에이전트 모두 언급)

| 항목 | 설명 |
|------|------|
| **보안/민감정보** | `~/.ctx/`에 API 키 등 저장 금지 원칙 명시 |
| **컨텍스트 가시성** | "지금 뭐가 로드됐지?" 쉽게 확인 (`ctx status`) |
| **성능 최적화** | 캐싱, registry 활용, 범위 제한 |

#### 권장 (Codex 언급)

| 항목 | 설명 |
|------|------|
| **충돌 정책** | Local/Project/Global 중복 시 처리 규칙 명시 |
| **가이드 템플릿** | 각 레벨에 "무엇을 적어야 하는지" 예시 제공 |

#### 권장 (Gemini 언급)

| 항목 | 설명 |
|------|------|
| **Sync 재정의** | Project(.ctx/)는 Git 공유, Global(~/.ctx/)는 개인 |
| **Local 파일 Git 관리 선택** | `*.ctx.md`를 `.gitignore`에 넣을지 사용자 선택 |

---

## 최종 권장 액션 플랜

```
Phase 1: 핵심 기반 (Load 강화)
├─ PostToolUse hook 구현 (성능 고려한 캐싱 포함)
├─ registry.yaml 기반 빠른 조회
├─ ctx status로 로드된 컨텍스트 확인
└─ 로드 범위/시점 명확히 문서화

Phase 2: 3-Level 구조 도입
├─ ~/.ctx/ 지원 (ctx init --global)
├─ ctx/ → .ctx/ 마이그레이션
├─ Config 계층화 (Global → Project 오버라이드)
└─ 충돌 정책 정의 (Local > Project > Global)

Phase 3: Work 단순화
├─ 기존 work 커맨드 분해/재정의
├─ issue store 의존성 제거 또는 선택적으로
└─ 사용자 Git 전략 존중

Phase 4: 가이드 & 보안
├─ 각 레벨별 "무엇을 적어야 하는지" 가이드
├─ 민감정보 금지 원칙 문서화
└─ Windows 호환성 확인
```

---

## Council 결론

> **"3-Level 구조는 검증된 패턴이며, 자동 로드가 핵심 가치다.
> 단, 성능과 가시성을 반드시 챙겨야 한다."**

두 에이전트 모두 방향성에 동의하면서, 실행 시 주의할 점들을 구체적으로 짚어줬습니다.

### 성패를 가를 핵심 요소
1. **자동 로드의 성능 최적화** - 캐싱, registry 활용
2. **"뭐가 로드됐는지" 가시성** - ctx status 강화
3. **보안 원칙 명시** - ~/.ctx/ 민감정보 금지

### 차별화 포인트
- Codex: 충돌 정책, 가이드 템플릿 강조
- Gemini: Sync 재정의, 컨텍스트 출처 표시 강조

두 관점을 모두 수용하여 구현하면 더 완성도 높은 시스템이 될 것입니다.
